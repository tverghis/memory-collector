#!/usr/bin/env Rscript

# Simplified script for analyzing and visualizing CPU utilization metrics
# Works with CSV files generated by convert_cpu_metrics.sh

# Load required libraries
library(ggplot2)
library(dplyr)
library(readr)
library(tidyr)

# Parse command line arguments
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 1) {
  cat("Usage: Rscript plot_cpu_utilization_simple.R <cpu_metrics_csv> [process_name] [output_file] [top_n_processes]\n")
  cat("  <cpu_metrics_csv>: Path to the CPU metrics CSV file (converted format)\n")
  cat("  [process_name]: Name of the process to analyze (default: \"collector\")\n")
  cat("  [output_file]: Base name for output files (default: \"cpu_utilization\")\n")
  cat("  [top_n_processes]: Number of top CPU consumers to show individually (default: 15)\n")
  quit(status = 1)
}

cpu_metrics_file <- args[1]
process_name <- if (length(args) >= 2) args[2] else "collector"
output_file <- if (length(args) >= 3) args[3] else "cpu_utilization"
top_n_processes <- if (length(args) >= 4) as.numeric(args[4]) else 15

# Start timing
start_time <- Sys.time()

# Read the CSV file
cat("Reading CPU metrics from", cpu_metrics_file, "...\n")
cpu_data <- read_csv(cpu_metrics_file, show_col_types = FALSE)

# Calculate elapsed time
if (nrow(cpu_data) > 0) {
  min_timestamp <- min(cpu_data$timestamp, na.rm = TRUE)
  cpu_data$elapsed_time <- cpu_data$timestamp - min_timestamp
}

cat("Found", nrow(cpu_data), "data points across", length(unique(cpu_data$timestamp)), "timestamps\n")

# Filter data for the target process
cat("Filtering data for process:", process_name, "...\n")
process_data <- filter(cpu_data, grepl(process_name, command, ignore.case = TRUE))
cat("Found", nrow(process_data), "rows for process:", process_name, "\n")

# Filter data for non-target processes (all other processes)
non_process_data <- filter(cpu_data, !grepl(process_name, command, ignore.case = TRUE))

if (nrow(process_data) == 0) {
  warning(paste("No data found for process", process_name))
  cat("\nNo data found for process", process_name, "\n")
  cat("Available processes:\n")
  print(sort(unique(cpu_data$command)))
  quit(status = 1)
}

# Show sample of filtered data
if (nrow(process_data) > 0) {
  cat("Sample of", process_name, "process data (first 5 rows):\n")
  print(head(select(process_data, timestamp, uid, pid, usr_pct, system_pct, cpu_pct, command), 5))
}

# Convert CPU percentages to millicores (percentage points of a single core * 10)
cat("Calculating CPU metrics...\n")
process_data <- process_data %>%
  mutate(
    usr_millicores = usr_pct * 10,
    system_millicores = system_pct * 10,
    total_millicores = cpu_pct * 10
  )

# Aggregate non-process data by timestamp
non_process_summary <- non_process_data %>%
  group_by(elapsed_time) %>%
  summarize(
    total_usr_millicores = sum(usr_pct, na.rm = TRUE) * 10,
    total_system_millicores = sum(system_pct, na.rm = TRUE) * 10,
    total_millicores = sum(cpu_pct, na.rm = TRUE) * 10
  )

# Generate Graph A: Target Process CPU Usage
cat("Generating plots...\n")
if (nrow(process_data) > 0) {
  plot_A <- ggplot(process_data, aes(x = elapsed_time, y = total_millicores)) +
    geom_line(color = "#4285F4", linewidth = 1) +
    labs(
      title = paste(process_name, "CPU Utilization"),
      subtitle = "Total CPU usage over time",
      x = "Time (seconds)",
      y = "CPU Utilization (millicores)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5)
    )
  
  # Save Graph A
  ggsave(paste0(output_file, "_process.png"), plot_A, width = 10, height = 6)
  ggsave(paste0(output_file, "_process.pdf"), plot_A, width = 10, height = 6)
  cat("Saved", process_name, "CPU utilization plot to", paste0(output_file, "_process.png"), "and", paste0(output_file, "_process.pdf"), "\n")
  
  # Print summary statistics
  cat("\nSummary statistics for", process_name, "process:\n")
  cat("  Mean user-space CPU utilization:", mean(process_data$usr_pct, na.rm = TRUE), "%\n")
  cat("  Mean kernel-space CPU utilization:", mean(process_data$system_pct, na.rm = TRUE), "%\n")
  cat("  Mean total CPU utilization:", mean(process_data$cpu_pct, na.rm = TRUE), "%\n")
  cat("  Peak CPU utilization:", max(process_data$cpu_pct, na.rm = TRUE), "%\n")
} else {
  cat("No data available for", process_name, "process. Skipping Graph A.\n")
}

# Generate Graph B: Non-Target Process CPU Usage
if (nrow(non_process_summary) > 0) {
  plot_B <- ggplot(non_process_summary, aes(x = elapsed_time, y = total_millicores)) +
    geom_line(color = "#EA4335", linewidth = 1) +
    labs(
      title = "Workload CPU Utilization",
      subtitle = "Total CPU usage of all other processes",
      x = "Time (seconds)",
      y = "CPU Utilization (millicores)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5)
    )
  
  # Save Graph B
  ggsave(paste0(output_file, "_other_processes.png"), plot_B, width = 10, height = 6)
  ggsave(paste0(output_file, "_other_processes.pdf"), plot_B, width = 10, height = 6)
  cat("Saved workload CPU utilization plot to", paste0(output_file, "_other_processes.png"), "and", paste0(output_file, "_other_processes.pdf"), "\n")
  
  # Print summary statistics
  cat("\nSummary statistics for workload processes:\n")
  cat("  Mean total CPU utilization:", mean(non_process_summary$total_millicores, na.rm = TRUE) / 10, "%\n")
  cat("  Peak total CPU utilization:", max(non_process_summary$total_millicores, na.rm = TRUE) / 10, "%\n")
} else {
  cat("No data available for workload processes. Skipping Graph B.\n")
}

# Generate combined graph with facets if both datasets are available
if (nrow(process_data) > 0 && nrow(non_process_summary) > 0) {
  # Prepare data for combined plot with facets
  process_data_sum <- process_data %>%
    group_by(elapsed_time) %>%
    summarize(
      millicores = sum(total_millicores, na.rm = TRUE)
    ) %>%
    mutate(type = process_name)
  
  non_process_data_sum <- non_process_summary %>%
    mutate(
      millicores = total_millicores,
      type = "Workload"
    ) %>%
    select(elapsed_time, millicores, type)
  
  combined_data <- bind_rows(process_data_sum, non_process_data_sum) %>%
    mutate(type = factor(type, levels = c(process_name, "Workload")))
  
  # Create faceted plot
  plot_facet <- ggplot(combined_data, aes(x = elapsed_time, y = millicores, color = type)) +
    geom_line(linewidth = 1) +
    facet_grid(type ~ ., scales = "free_y") +
    scale_color_manual(values = c("Collector" = "#4285F4", "Workload" = "#EA4335", 
                                 "java" = "#34A853", "collector" = "#4285F4")) +
    labs(
      title = "CPU Utilization Comparison",
      subtitle = paste(process_name, "vs Workload CPU usage"),
      x = "Time (seconds)",
      y = "CPU Utilization (millicores)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5),
      legend.position = "none",
      strip.text = element_text(face = "bold"),
      strip.background = element_rect(fill = "lightgray", color = NA)
    )
  
  # Save faceted graph
  ggsave(paste0(output_file, "_comparison.png"), plot_facet, width = 10, height = 8)
  ggsave(paste0(output_file, "_comparison.pdf"), plot_facet, width = 10, height = 8)
  cat("Saved CPU utilization comparison plot to", paste0(output_file, "_comparison.png"), "and", paste0(output_file, "_comparison.pdf"), "\n")
}

# Generate Graph C: Stacked bar chart of top CPU consumers
cat("Generating stacked bar chart of top CPU consumers...\n")

# First, calculate total CPU usage per process over time
process_totals <- cpu_data %>%
  # Convert to millicores
  mutate(total_millicores = cpu_pct * 10) %>%
  # Group by timestamp and command
  group_by(elapsed_time, command) %>%
  # Sum CPU usage for each process at each timestamp
  summarize(millicores = sum(total_millicores, na.rm = TRUE), .groups = 'drop')

# Identify top N CPU consumers based on average CPU usage
top_processes <- process_totals %>%
  group_by(command) %>%
  summarize(avg_millicores = mean(millicores, na.rm = TRUE), .groups = 'drop') %>%
  arrange(desc(avg_millicores)) %>%
  slice_head(n = top_n_processes) %>%
  pull(command)

cat("Top", top_n_processes, "CPU consumers:\n")
print(process_totals %>%
  group_by(command) %>%
  summarize(avg_millicores = mean(millicores, na.rm = TRUE), .groups = 'drop') %>%
  arrange(desc(avg_millicores)) %>%
  slice_head(n = top_n_processes))

# Prepare data for stacked bar plot, grouping non-top processes as "other"
stacked_data <- process_totals %>%
  mutate(
    process_group = ifelse(command %in% top_processes, command, "other")
  ) %>%
  group_by(elapsed_time, process_group) %>%
  summarize(millicores = sum(millicores, na.rm = TRUE), .groups = 'drop')

# Generate colors for the stacked bar plot
all_colors <- colorRampPalette(
  c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", 
    "#FFFF33", "#A65628", "#F781BF", "#999999")
)(length(unique(stacked_data$process_group)))

names(all_colors) <- unique(stacked_data$process_group)

# If "other" is present, make it gray and place it at the bottom of the stack
if ("other" %in% names(all_colors)) {
  all_colors["other"] <- "#CCCCCC"  # Gray for "other"
  
  # Reorder factor levels to ensure "other" is at the bottom of the stack
  process_groups <- setdiff(names(all_colors), "other")
  stacked_data$process_group <- factor(stacked_data$process_group, 
                               levels = c(process_groups, "other"))
}

# Create stacked bar plot
plot_stacked <- ggplot(stacked_data, aes(x = elapsed_time, y = millicores, fill = process_group)) +
  geom_col(position = "stack", width = 0.9) +
  scale_fill_manual(values = all_colors) +
  labs(
    title = "CPU Utilization by Process",
    subtitle = paste("Top", top_n_processes, "CPU consumers with others grouped"),
    x = "Time (seconds)",
    y = "CPU Utilization (millicores)",
    fill = "Process"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Save stacked bar plot
ggsave(paste0(output_file, "_stacked.png"), plot_stacked, width = 12, height = 8)
ggsave(paste0(output_file, "_stacked.pdf"), plot_stacked, width = 12, height = 8)
cat("Saved stacked CPU utilization plot to", paste0(output_file, "_stacked.png"), "and", paste0(output_file, "_stacked.pdf"), "\n")

total_time <- Sys.time() - start_time
cat("\nCPU utilization analysis complete in", round(as.numeric(total_time), 2), attr(total_time, "units"), "\n") 